/* 
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
*/

/* 看起来很简单的题目，但很容易想错动态转移方程，做此题应该仔细考虑取值带来的副作用
- 最后一位 i 取值范围是 0-9，先不考虑边界情况 0
    - 1<i<9 
        不考虑与前一个元素合并，dp[i] = dp[i-1]
        考虑合并，两位数合并情况可分为 11 - 26 , > 26 ; 
            前者会将最后两个元素捆绑，即在dp[i-2]每一种解码后加上这个捆绑元素，属于新增了dp[i-2]个花样，但 i-2 也可能根本不存在，当i===1时，dp[i]直接+1
            后者无法新增
        综合 dp[i] = dp[i-1] + dp[i-2] || dp[i] = dp[i-1]
    - i === 0
        考虑合并的情况 若前一个元素为 1 或 2 , dp[i] = dp[i-2] , 否则会出现错误，但题目保证不会有这种情况
        捆绑为10-20可以放入上一种情况中（line 21），即捆绑后为 10-26
        不考虑合并，则 0 只能出现在前导元素中，如 0XXXXX，为边界情况直接返回 0 即可
- 综合来看，
    if(s[0]==='0') res = 0
    else dp[i] = dp[i-1](1<i<9) + dp[i-2](i + i-1 ∈ [10,26])
*/

function numDecodings(s: string): number {
  if (s[0] === "0") return 0;

  const dp = Array(s.length).fill(0);

  dp[0] = 1;

  for (let i = 1; i < s.length; i++) {
    const single = +s[i];
    const double = +(s[i - 1] + s[i]);

    if (single > 0) dp[i] += dp[i - 1];
    if (double > 9 && double < 27) {
      if (i === 1) dp[i] += 1;
      if (i !== 1) dp[i] += dp[i - 2];
    }
  }

  return dp[s.length - 1];
}

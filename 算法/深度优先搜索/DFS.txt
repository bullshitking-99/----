· 深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。
    它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，
    然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。

· DFS和BFS的比较
    广度优先搜索的缺点：在树的层次较深&子节点数较多的情况下，消耗内存十分严重。
    广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况。

    那么深度优先就可以克服这个缺点，因为每次搜的过程，每一层只需维护一个节点。
    但回过头想想，广度优先能够找到最短路径，那深度优先能否找到呢？深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，
    所以你还得继续走别的路去判断是否是最短路？

    于是深度优先搜索的缺点也出来了：难以寻找最优解，仅仅只能寻找有解。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点。


/**
 * DFS核心伪代码
 * 前置条件是visit数组全部设置成false
 * @param n 当前开始搜索的节点
 * @param d 当前到达的深度
 * @return 是否有解
 */
bool DFS(Node n, int d){
    if (isEnd(n, d)){//一旦搜索深度到达一个结束状态，就返回true
        return true;
    }
 
    for (Node nextNode in n){//遍历n相邻的节点nextNode
        if (!visit[nextNode]){//
            visit[nextNode] = true;//在下一步搜索中，nextNode不能再次出现
            if (DFS(nextNode, d+1)){//如果搜索出有解
                //做些其他事情，例如记录结果深度等
                return true;
            }
 
            //重新设置成false，因为它有可能出现在下一次搜索的别的路径中
            visit[nextNode] = false;
        }
    }
    return false;//本次搜索无解
}